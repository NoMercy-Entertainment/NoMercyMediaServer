name: 'Version and Release Management'

on:
  workflow_call:
    outputs:
      version:
        description: 'Version that was created'
        value: ${{ jobs.version_management.outputs.version }}
      should_deploy:
        description: 'Whether deployment should proceed'
        value: ${{ jobs.version_management.outputs.should_deploy }}

jobs:
  version_management:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get-version.outputs.version }}
      should_deploy: ${{ steps.check-deploy.outputs.should_deploy }}

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Setup .NET Environment
        uses: ./.github/actions/setup-dotnet
        with:
          dotnet-version: 10.0.x

      - name: Get latest tag
        id: get-tag
        uses: WyriHaximus/github-action-get-previous-tag@v1
        with:
          fallback: v0.1.201

      - name: Check for source changes
        id: check-changes
        if: github.ref == 'refs/heads/dev'
        run: |
          if [[ "${{ github.event_name }}" == "release" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "has_source_changes=true" >> $GITHUB_OUTPUT
            echo "Release or manual trigger - proceeding with full pipeline"
          else
            # Check for actual source code changes since last tag
            LATEST_TAG="${{ steps.get-tag.outputs.tag }}"
            if git diff --quiet "$LATEST_TAG" HEAD -- src/ 2>/dev/null; then
              echo "has_source_changes=false" >> $GITHUB_OUTPUT
              echo "No source code changes detected since $LATEST_TAG"
            else
              echo "has_source_changes=true" >> $GITHUB_OUTPUT
              echo "Source code changes detected - proceeding with version bump and full pipeline"
            fi
          fi

      - name: Calculate new version
        id: calc-version
        if: steps.check-changes.outputs.has_source_changes == 'true'
        run: |
          LATEST_TAG="${{ steps.get-tag.outputs.tag }}"
          VERSION_NO_V=${LATEST_TAG#v}
          MAJOR=$(echo "$VERSION_NO_V" | cut -d. -f1)
          MINOR=$(echo "$VERSION_NO_V" | cut -d. -f2)
          PATCH=$(echo "$VERSION_NO_V" | cut -d. -f3)
          NEW_PATCH=$(($PATCH + 1))
          NEW_VERSION="$MAJOR.$MINOR.$NEW_PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Calculated new version: $NEW_VERSION"

      - name: Update version in csproj
        if: steps.check-changes.outputs.has_source_changes == 'true'
        run: |
          NEW_VERSION="${{ steps.calc-version.outputs.new_version }}"
          sed -i "s|<Version>.*</Version>|<Version>${NEW_VERSION}</Version>|" src/NoMercy.Server/NoMercy.Server.csproj
          echo "Updated NoMercy.Server.csproj to version $NEW_VERSION"

      - name: Get Version
        id: get-version
        uses: kzrnm/get-net-sdk-project-versions-action@v2
        with:
          proj-path: ./src/NoMercy.Server/NoMercy.Server.csproj

      - name: Generate changelog
        id: changelog
        if: github.ref == 'refs/heads/dev' && steps.check-changes.outputs.has_source_changes == 'true'
        run: |
          LATEST_TAG="${{ steps.get-tag.outputs.tag }}"

          # Get commits since last tag, excluding version bump commits
          COMMITS=$(git log "$LATEST_TAG"..HEAD --pretty=format:"%s" -- src/ | grep -v "^chore: bump version" || true)

          # Initialize changelog sections
          FEATURES=""
          FIXES=""
          REFACTOR=""
          OTHER=""

          while IFS= read -r line; do
            [[ -z "$line" ]] && continue

            # Extract message without scope for cleaner output
            MSG=$(echo "$line" | sed -E 's/^[a-z]+(\([^)]+\))?:\s*//')

            if [[ "$line" =~ ^feat ]]; then
              FEATURES="${FEATURES}- ${MSG}"$'\n'
            elif [[ "$line" =~ ^fix ]]; then
              FIXES="${FIXES}- ${MSG}"$'\n'
            elif [[ "$line" =~ ^refactor ]]; then
              REFACTOR="${REFACTOR}- ${MSG}"$'\n'
            elif [[ ! "$line" =~ ^(chore|docs|style|test|ci) ]]; then
              OTHER="${OTHER}- ${MSG}"$'\n'
            fi
          done <<< "$COMMITS"

          # Build changelog body
          CHANGELOG=""
          [[ -n "$FEATURES" ]] && CHANGELOG="${CHANGELOG}### Features"$'\n'"${FEATURES}"$'\n'
          [[ -n "$FIXES" ]] && CHANGELOG="${CHANGELOG}### Fixes"$'\n'"${FIXES}"$'\n'
          [[ -n "$REFACTOR" ]] && CHANGELOG="${CHANGELOG}### Refactoring"$'\n'"${REFACTOR}"$'\n'
          [[ -n "$OTHER" ]] && CHANGELOG="${CHANGELOG}### Other"$'\n'"${OTHER}"$'\n'

          # Fallback if no categorized commits
          if [[ -z "$CHANGELOG" ]]; then
            CHANGELOG="Maintenance release with various improvements."
          fi

          # Save to file for multi-line support
          echo "$CHANGELOG" > /tmp/changelog.txt
          echo "Generated changelog:"
          cat /tmp/changelog.txt

      - name: Squash merge to main and sync dev
        if: github.ref == 'refs/heads/dev' && steps.check-changes.outputs.has_source_changes == 'true'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

          NEW_VERSION="${{ steps.get-version.outputs.version }}"

          # Stage the version change locally (don't push to dev yet)
          git add src/NoMercy.Server/NoMercy.Server.csproj
          git commit -m "chore: bump version to $NEW_VERSION" || true

          # Store the current dev state
          DEV_HEAD=$(git rev-parse HEAD)

          # Checkout main and pull latest
          git fetch origin main
          git checkout main
          git reset --hard origin/main

          # Squash merge dev into main
          git merge --squash origin/dev

          # Also include the version bump we made locally
          git checkout $DEV_HEAD -- src/NoMercy.Server/NoMercy.Server.csproj
          git add src/NoMercy.Server/NoMercy.Server.csproj

          # Read changelog from file
          CHANGELOG=$(cat /tmp/changelog.txt)

          # Create the squash commit with version and changelog
          git commit -m "release: v$NEW_VERSION" -m "$CHANGELOG"

          # Push to main
          git push origin main

          # Now reset dev to match main (clean linear history)
          git checkout dev
          git reset --hard main
          git push --force-with-lease origin dev

          echo "Squash merged dev into main as v$NEW_VERSION and synced dev"

      - name: Check deployment conditions
        id: check-deploy
        run: |
          if [[ "${{ github.event_name }}" == "release" ]] || [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/dev" ]] && [[ "${{ steps.check-changes.outputs.has_source_changes }}" == "true" ]]; then
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi
