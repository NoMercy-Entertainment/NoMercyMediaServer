name: 'Build .NET Project'
description: 'Builds a .NET project for all platforms (Linux, Windows, macOS)'
author: 'NoMercy Entertainment'

inputs:
  project:
    description: 'Project name (Server, App)'
    required: true
  dotnet-version:
    description: '.NET version to use'
    required: false
    default: '9.0.x'

outputs:
  artifact-name:
    description: 'Name of the uploaded artifact'
    value: ${{ steps.upload.outputs.artifact-id }}

runs:
  using: 'composite'
  steps:
    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: ${{ inputs.dotnet-version }}

    - name: Set up Node.js
      if: inputs.project == 'App'
      uses: actions/setup-node@v3
      with:
        node-version: 20

    - name: Restore dependencies
      shell: bash
      run: dotnet restore NoMercy.Server.sln

    - name: Pull App Files
      if: inputs.project == 'App'
      uses: actions/checkout@v5
      with:
        repository: NoMercy-Entertainment/NoMercyApp
        path: ./src/NoMercy.App/Resources/wwwroot
        fetch-depth: 1
        fetch-tags: false
        ref: gh-pages

    - name: Move App Files
      if: inputs.project == 'App'
      shell: bash
      run: |
        mv ./src/NoMercy.App/Resources/wwwroot/* ./src/NoMercy.App/Resources
        rm -rf ./src/NoMercy.App/Resources/wwwroot

    - name: Build Project for All Platforms
      shell: bash
      run: |
        mkdir -p ./output
        
        PROJECT_PATH="./src/NoMercy.${{ inputs.project }}/NoMercy.${{ inputs.project }}.csproj"
        
        # Set correct project names based on actual target names
        if [ "${{ inputs.project }}" == "Server" ]; then
          PROJECT_NAME="NoMercyMediaServer"
        else
          PROJECT_NAME="NoMercy${{ inputs.project }}"
        fi
        
        # Determine if we need PublishTrimmed
        TRIMMED_FLAG=""
        if [ "${{ inputs.project }}" == "App" ]; then
          TRIMMED_FLAG="/p:PublishTrimmed=true"
        fi
        
        echo "Building $PROJECT_NAME for all platforms..."
        
        # Linux Build
        echo "Building for Linux..."
        dotnet publish "$PROJECT_PATH" \
          --configuration Release \
          --runtime linux-x64 \
          --self-contained true \
          /p:PublishSingleFile=true \
          /p:IncludeNativeLibrariesForSelfExtract=true \
          /p:IncludeAllContentForSelfExtract=true \
          /p:EnableCompressionInSingleFile=true \
          /p:DebugType=None \
          /p:DebugSymbols=false \
          /p:PublishReadyToRun=false \
          /p:OutputFileName="$PROJECT_NAME" \
          $TRIMMED_FLAG \
          --output ./output
        mv "./output/$PROJECT_NAME" "./output/$PROJECT_NAME-linux-x64"
        
        # Windows Build
        echo "Building for Windows..."
        dotnet publish "$PROJECT_PATH" \
          --configuration Release \
          --runtime win-x64 \
          --self-contained true \
          /p:PublishSingleFile=true \
          /p:IncludeNativeLibrariesForSelfExtract=true \
          /p:IncludeAllContentForSelfExtract=true \
          /p:EnableCompressionInSingleFile=true \
          /p:DebugType=None \
          /p:DebugSymbols=false \
          /p:PublishReadyToRun=false \
          /p:OutputFileName="$PROJECT_NAME" \
          $TRIMMED_FLAG \
          --output ./output
        mv "./output/$PROJECT_NAME.exe" "./output/$PROJECT_NAME-windows-x64.exe"
        
        # macOS Build
        echo "Building for macOS..."
        dotnet publish "$PROJECT_PATH" \
          --configuration Release \
          --runtime osx-x64 \
          --self-contained true \
          /p:PublishSingleFile=true \
          /p:IncludeNativeLibrariesForSelfExtract=true \
          /p:IncludeAllContentForSelfExtract=true \
          /p:EnableCompressionInSingleFile=true \
          /p:DebugType=None \
          /p:DebugSymbols=false \
          /p:PublishReadyToRun=false \
          /p:OutputFileName="$PROJECT_NAME" \
          $TRIMMED_FLAG \
          --output ./output
        
        echo "Build completed for all platforms!"

    - name: Create macOS App Bundle
      shell: bash
      run: |
        # Set correct project names based on actual target names
        if [ "${{ inputs.project }}" == "Server" ]; then
          PROJECT_NAME="NoMercyMediaServer"
        else
          PROJECT_NAME="NoMercy${{ inputs.project }}"
        fi
        
        echo "Creating macOS App Bundle for $PROJECT_NAME..."
        mkdir -p "./output/$PROJECT_NAME.app/Contents/MacOS"
        mkdir -p "./output/$PROJECT_NAME.app/Contents/Resources"
        cp "./output/$PROJECT_NAME" "./output/$PROJECT_NAME.app/Contents/MacOS/"
        
        # Copy appropriate Info.plist based on project
        if [ "${{ inputs.project }}" == "Server" ]; then
          cp ./assets/macos/Info.plist "./output/$PROJECT_NAME.app/Contents/"
        else
          cp ./assets/macos/Info.plist.app "./output/$PROJECT_NAME.app/Contents/Info.plist"
        fi
        
        cp ./assets/icons/icon.icns "./output/$PROJECT_NAME.app/Contents/Resources/AppIcon.icns"
        chmod +x "./output/$PROJECT_NAME.app/Contents/MacOS/$PROJECT_NAME"
        
        # Create tar.gz for the app bundle
        tar -czf "./output/$PROJECT_NAME-macos-x64.tar.gz" -C ./output "$PROJECT_NAME.app"
        
        # Keep the raw binary for other uses
        mv "./output/$PROJECT_NAME" "./output/$PROJECT_NAME-macos-x64"
        
        echo "macOS App Bundle created successfully!"

    - name: Create DMG (macOS Installer)
      shell: bash
      continue-on-error: true
      run: |
        # Set correct project names based on actual target names
        if [ "${{ inputs.project }}" == "Server" ]; then
          PROJECT_NAME="NoMercyMediaServer"
        else
          PROJECT_NAME="NoMercy${{ inputs.project }}"
        fi
        
        echo "Creating DMG for $PROJECT_NAME..."
        npm install -g create-dmg
        
        npx create-dmg \
          "./output/$PROJECT_NAME.app" \
          ./output \
          --overwrite \
          --dmg-title="$PROJECT_NAME" \
          --window-size 500 300 \
          --icon-size 128 \
          --icon "$PROJECT_NAME.app" 100 150 \
          --app-drop-link 400 150 || echo "DMG creation failed, continuing..."
        
        # Rename DMG with consistent naming (find any created DMG and rename it)
        find ./output -name "*.dmg" -not -name "*$PROJECT_NAME*" -exec mv {} "./output/$PROJECT_NAME-macos-x64.dmg" \; || echo "No DMG to rename"
        
        echo "DMG creation completed!"

    - name: List Generated Files
      shell: bash
      run: |
        echo "Generated files:"
        ls -la ./output/

    - name: Upload Artifacts
      id: upload
      uses: actions/upload-artifact@v4
      with:
        name: ${{ inputs.project }}-executables
        path: ./output/*
        retention-days: 30
