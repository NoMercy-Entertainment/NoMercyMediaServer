## EncoderV2 Development Progress

### 2026-02-03: Database Entities Implementation

**Task Completed:** Implement Phase 1 database entities for EncoderV2

**Changes Made:**

1. Created `EncodingJob.cs` in `src/NoMercy.Database/Models/`
   - Entity for encoding jobs with profile reference, input/output paths, state tracking
   - Includes ProfileSnapshotJson for immutable profile state at job creation
   - Supports job states: queued, encoding, completed, failed, cancelled

2. Created `EncodingTask.cs` in `src/NoMercy.Database/Models/`
   - Entity for individual tasks within an encoding job
   - Supports task types: video_encoding, audio_encoding, subtitle_extraction, etc.
   - Includes dependency tracking (DependenciesJson) for task sequencing
   - Retry mechanism with configurable max retries

3. Created `EncoderNode.cs` in `src/NoMercy.Database/Models/`
   - Entity for distributed encoder nodes
   - Tracks hardware capabilities (GPU, CPU cores, memory)
   - Health monitoring with heartbeat tracking
   - Supported hardware acceleration types (NVENC, QSV, VAAPI, etc.)

4. Created `EncodingProgress.cs` in `src/NoMercy.Database/Models/`
   - Entity for progress snapshots during encoding
   - Tracks FPS, speed, bitrate, current time, estimated remaining
   - Supports both frame count and time-based progress

5. Updated `QueueContext.cs`
   - Added DbSet<EncodingJob> EncodingJobs
   - Added DbSet<EncodingTask> EncodingTasks
   - Added DbSet<EncoderNode> EncoderNodes
   - Added DbSet<EncodingProgress> EncodingProgress

**Build Status:**
- NoMercy.Database: BUILD SUCCEEDED
- NoMercy.EncoderV2: BUILD SUCCEEDED

**Next Steps:**
- ~~Create EF Core migration for new tables~~ ✓
- Build ProfileManager with CRUD operations
- Implement profile validation

---

### 2026-02-03: EF Core Migration for EncoderV2 Tables

**Task Completed:** Create EF Core migration for new EncoderV2 tables using `dotnet ef` CLI

**Changes Made:**

1. Added `UlidToStringConverter` to `QueueContext.ConfigureConventions()`
   - Required for Ulid properties in EncoderV2 entities

2. Created `QueueContextDesignTimeFactory.cs`
   - Implements `IDesignTimeDbContextFactory<QueueContext>`
   - Enables migration generation without running the full application

3. Removed `EncoderProfile` navigation property from `EncodingJob`
   - Cross-database reference (QueueContext → MediaContext) not supported
   - ProfileId kept as Ulid? for application-level reference

4. Added `Microsoft.EntityFrameworkCore.Design` package to Server project
   - Required for EF Core CLI tools

5. Generated migration `20260203201619_AddEncoderV2Tables.cs` via CLI:
   ```
   dotnet ef migrations add AddEncoderV2Tables --context QueueContext \
     --output-dir Migrations/Queue --project src/NoMercy.Database \
     --startup-project src/NoMercy.Server
   ```

**Tables Created:**
- `EncoderNodes`: Distributed node registry with hardware capabilities
- `EncodingJobs`: Job tracking with profile snapshots and state management
- `EncodingTasks`: Individual tasks with dependencies, retry logic, node assignment
- `EncodingProgress`: Real-time progress snapshots for monitoring

**Indexes Created:**
- `IX_EncodingProgress_TaskId`
- `IX_EncodingTasks_AssignedNodeId`
- `IX_EncodingTasks_JobId`

**Build Status:**
- NoMercy.Database: BUILD SUCCEEDED

**Next Steps:**
- ~~Build ProfileManager with CRUD operations~~ ✓ (already existed)
- ~~Implement profile validation~~ ✓ (already existed)
- ~~Create default profiles (HLS, MP4, MKV variants)~~ ✓ (already existed)

---

### 2026-02-03: FontExtractor Implementation (Phase 3)

**Task Completed:** Implement FontExtractor for embedded font extraction

**Changes Made:**

1. Created `FontExtractor.cs` in `src/NoMercy.EncoderV2/PostProcessing/`
   - Implements `IFontExtractor` interface for dependency injection
   - Extracts embedded fonts from media files (MKV, ASS/SSA containers)
   - Uses FFmpeg `-dump_attachment:t` command for extraction
   - Generates `fonts.json` manifest with MIME types for web delivery
   - Supports async operations with cancellation tokens

2. Key Features:
   - `ExtractFontsAsync()`: Extracts all fonts and creates manifest
   - `HasFontsAsync()`: Quick check for font presence
   - `GetFontMetadataAsync()`: Get font info without extraction
   - Font detection by MIME type, file extension, and codec name
   - Supports TTF, OTF, WOFF, WOFF2, EOT formats

3. Updated `DependencyInjection.cs`
   - Added `using NoMercy.EncoderV2.PostProcessing;`
   - Registered `IFontExtractor` as scoped service

**Build Status:**
- NoMercy.EncoderV2: BUILD SUCCEEDED
- Full solution: BUILD SUCCEEDED

**Phase 3 Progress (Stream Processing):**
- ✅ VideoStreamProcessor
- ✅ AudioStreamProcessor
- ✅ SubtitleStreamProcessor
- ✅ FontExtractor
- ❌ ChapterProcessor
- ❌ SpriteGenerator

**Next Steps:**
- ~~Implement ChapterProcessor for chapter marker extraction~~ ✓
- Implement SpriteGenerator for thumbnail sprite sheets

---

### 2026-02-03: ChapterProcessor Implementation (Phase 3)

**Task Completed:** Implement ChapterProcessor for chapter extraction to WebVTT

**Changes Made:**

1. Created `ChapterProcessor.cs` in `src/NoMercy.EncoderV2/PostProcessing/`
   - Implements `IChapterProcessor` interface for dependency injection
   - Extracts chapter markers from media files using FFprobe
   - Generates `chapters.vtt` file in WebVTT format for video players
   - Supports MKV, MP4, and other container formats with embedded chapters

2. Key Features:
   - `ExtractChaptersAsync()`: Full extraction with VTT file generation
   - `HasChaptersAsync()`: Quick check for chapter presence
   - `GetChapterMetadataAsync()`: Get chapter info without file generation
   - `WriteChaptersAsync()`: Pipeline-compatible alias for ExtractChaptersAsync
   - Handles missing chapters gracefully (returns success with empty list)
   - Fallback chapter titles ("Chapter N") when title is missing

3. DTOs Created:
   - `ChapterInfo`: Public DTO with Id, Title, StartTime, EndTime
   - `ChapterExtractionResult`: Result object with Success, OutputPath, Chapters, ErrorMessage
   - `FfprobeChapterRoot`, `FfprobeChapter`, `FfprobeTags`: Internal DTOs for JSON parsing

4. Updated `ServiceCollectionExtensions.cs`
   - Added `using NoMercy.EncoderV2.PostProcessing;`
   - Registered `IChapterProcessor` as scoped service

**Build Status:**
- NoMercy.EncoderV2: BUILD SUCCEEDED

**Phase 3 Progress (Stream Processing):**
- ✅ VideoStreamProcessor
- ✅ AudioStreamProcessor
- ✅ SubtitleStreamProcessor
- ✅ FontExtractor
- ✅ ChapterProcessor
- ❌ SpriteGenerator

**Next Steps:**
- ~~Implement SpriteGenerator for thumbnail sprite sheets~~ ✓

---

### 2026-02-03: SpriteGenerator Implementation (Phase 3 Complete)

**Task Completed:** Implement SpriteGenerator for thumbnail sprite sheet generation

**Changes Made:**

1. Created `SpriteGenerator.cs` in `src/NoMercy.EncoderV2/PostProcessing/`
   - Implements `ISpriteGenerator` interface for dependency injection
   - Extracts thumbnails from media files at configurable intervals
   - Combines thumbnails into WebP sprite sheet using FFmpeg tile filter
   - Generates WebVTT file with xywh fragment identifiers for video player scrubbing

2. Key Features:
   - `GenerateSpriteAsync()`: Full extraction from media file with configurable dimensions/interval
   - `GenerateSpriteFromThumbnailsAsync()`: Create sprite from pre-extracted thumbnails
   - `GetDurationAsync()`: Query media file duration using FFprobe
   - `CalculateSpriteMetadata()`: Calculate grid dimensions and frame positions
   - Automatic cleanup of individual thumbnail files after sprite generation
   - Support for aspect ratio preservation when height is not specified

3. DTOs Created:
   - `SpriteFrame`: Individual frame info with index, timestamp, x, y, width, height
   - `SpriteMetadata`: Complete sprite info including grid dimensions and frame list
   - `SpriteGenerationResult`: Result object with Success, file paths, metadata, ErrorMessage
   - `FfprobeDurationRoot`, `FfprobeDurationFormat`: Internal DTOs for duration parsing

4. Updated DI Configuration:
   - Added `ISpriteGenerator` registration to `Composition/DependencyInjection.cs`
   - Added `ISpriteGenerator` registration to `DependencyInjection/ServiceCollectionExtensions.cs`
   - Both registered as scoped services (one per encoding job)

**Build Status:**
- NoMercy.EncoderV2: BUILD SUCCEEDED

**Phase 3 Progress (Stream Processing) - COMPLETE:**
- ✅ VideoStreamProcessor
- ✅ AudioStreamProcessor
- ✅ SubtitleStreamProcessor
- ✅ FontExtractor
- ✅ ChapterProcessor
- ✅ SpriteGenerator

**Next Steps (Phase 4: FFmpeg Integration):**
- ~~Implement FFmpegCommandBuilder~~ ✓ (already existed)
- ~~Implement HDRProcessor (HDR→SDR tonemap)~~ ✓
- ~~Implement ProgressMonitor (FFmpeg `-progress -` parsing)~~ ✓ (already existed)
- ~~Implement EncodingJobExecutor~~ ✓ (already existed)
- Implement PostProcessor

---

### 2026-02-03: HDRProcessor Implementation (Phase 4)

**Task Completed:** Implement HDRProcessor for HDR detection and tone mapping

**Changes Made:**

1. Created `IHdrProcessor.cs` in `src/NoMercy.EncoderV2/Processing/`
   - Interface for HDR detection and processing
   - Enums for HDR formats: HDR10, HDR10+, HLG, Dolby Vision
   - Enums for tone mapping algorithms: Hable, Reinhard, Mobius, BT.2390, Linear
   - Hardware acceleration options: CUDA, OpenCL, Vulkan
   - DTOs: HdrDetectionResult, HdrConversionResult, HdrProcessingOptions

2. Created `HdrProcessor.cs` in `src/NoMercy.EncoderV2/Processing/`
   - Implements `IHdrProcessor` interface for dependency injection
   - HDR detection via FFprobe with JSON parsing and regex fallback
   - Multiple tone mapping algorithm support with configurable parameters
   - Software tone mapping using zscale and tonemap filters
   - Hardware-accelerated filter chains for CUDA/OpenCL/Vulkan
   - SDR cache mechanism for sharing converted files across quality levels (PRD G8)
   - Recommended algorithm selection based on HDR format

3. Key Features:
   - `DetectHdrAsync()`: Analyzes media for HDR format, color space, and metadata
   - `ConvertToSdrAsync()`: Full HDR→SDR conversion with progress callback
   - `BuildToneMappingFilterChain()`: Builds FFmpeg filter string for tone mapping
   - `GetCachedSdrPath()`: Checks for cached SDR versions to avoid re-processing
   - `GetRecommendedAlgorithm()`: Returns best algorithm per HDR format
   - MaxCLL/MaxFALL metadata extraction
   - Master display color volume parsing
   - Dolby Vision side data detection

4. Updated DI Configuration:
   - Added `using NoMercy.EncoderV2.Processing;` to both DI files
   - Registered `IHdrProcessor` as scoped service in both configurations

**Build Status:**
- NoMercy.EncoderV2: BUILD SUCCEEDED

**Phase 4 Progress (FFmpeg Integration):**
- ✅ FFmpegCommandBuilder (pre-existing)
- ✅ HDRProcessor
- ✅ ProgressMonitor (pre-existing)
- ✅ EncodingJobExecutor (pre-existing)
- ❌ PostProcessor

**Next Steps:**
- ~~Implement PostProcessor for post-encoding tasks~~ ✓

---

### 2026-02-03: PostProcessor Implementation (Phase 4 Complete)

**Task Completed:** Implement PostProcessor for post-encoding orchestration

**Changes Made:**

1. Created `PostProcessor.cs` in `src/NoMercy.EncoderV2/PostProcessing/`
   - Implements `IPostProcessor` interface for dependency injection
   - Orchestrates all post-processing steps after encoding completes
   - Configurable via `PostProcessingOptions` for enabling/disabling features
   - Progress callback support for real-time UI updates

2. Key Features:
   - `ProcessAsync()`: Executes all enabled post-processing steps in sequence
   - `ExtractFontsAsync()`: Delegates to `IFontExtractor`
   - `ExtractChaptersAsync()`: Delegates to `IChapterProcessor`
   - `GenerateSpritesAsync()`: Delegates to `ISpriteGenerator`
   - `ValidateOutputAsync()`: Validates encoded output files and playlists
   - Master playlist generation for HLS from existing variant playlists
   - Parses video/audio folder naming conventions (video_1920x1080_SDR, audio_eng_aac)
   - Bandwidth estimation based on resolution and HDR status

3. DTOs Created:
   - `PostProcessingStepResult`: Individual step outcome with timing and metadata
   - `PostProcessingResult`: Aggregated result with all step outcomes
   - `PostProcessingOptions`: Configuration for enabling/disabling steps

4. Post-Processing Steps (in order):
   1. Font Extraction → fonts/ directory + fonts.json
   2. Chapter Extraction → chapters.vtt
   3. Sprite Generation → thumbs_*.webp + thumbs_*.vtt
   4. Output Validation → Verify playlists and media files
   5. Master Playlist Generation → {filename}.m3u8 (HLS only)

5. Updated Project Configuration:
   - Re-enabled `Validation/`, `Specifications/`, and `Streams/` folders in csproj
   - Only excludes specific files with actual broken dependencies:
     - `Validation/CodecValidator.cs` (needs IFFmpegService)
     - `Validation/ProfileValidator.cs` (needs excluded types)
     - `Validation/Rules/**/*.cs`

6. Updated DI Configuration:
   - Added `IOutputValidator`, `IHLSPlaylistGenerator` registrations
   - Added `IPostProcessor` registration as scoped service
   - Both `Composition/DependencyInjection.cs` and `DependencyInjection/ServiceCollectionExtensions.cs`

**Build Status:**
- NoMercy.EncoderV2: BUILD SUCCEEDED

**Phase 4 Progress (FFmpeg Integration) - COMPLETE:**
- ✅ FFmpegCommandBuilder (pre-existing)
- ✅ HDRProcessor
- ✅ ProgressMonitor (pre-existing)
- ✅ EncodingJobExecutor (pre-existing)
- ✅ PostProcessor

**Next Steps (Phase 5: Task Distribution):**
- ~~Implement TaskSplitter (Job → Task decomposition)~~ ✓
- Implement NodeSelector (capability matching)
- Implement JobDispatcher (queue integration)
- Implement NodeHealthMonitor (30-second health checks)

---

### 2026-02-03: TaskSplitter Implementation (Phase 5)

**Task Completed:** Implement TaskSplitter for job-to-task decomposition

**Changes Made:**

1. Enhanced `ITaskSplitter.cs` in `src/NoMercy.EncoderV2/Tasks/`
   - Added `TaskSplittingOptions` for configurable splitting behavior
   - Added `TaskSplitResult` with metadata (parallelism, critical path, HDR sharing)
   - Added `Optimal` strategy that auto-selects best approach
   - Extended `EncodingTaskDefinition` with Id, Description, OutputPath, RequiresGpu, EstimatedMemoryMb
   - Added `DetermineOptimalStrategy()` method
   - Added `ToEncodingTasks()` for database entity conversion

2. Implemented `TaskSplitter.cs` with full job decomposition:
   - **SingleTask Strategy**: Full encode as one task (simple jobs)
   - **ByResolution Strategy**: Separate task per quality level (multi-quality encoding)
   - **ByStreamType Strategy**: Split video/audio/subtitle processing
   - **BySegment Strategy**: Time-based splitting for long HLS content
   - **Optimal Strategy**: Auto-selects based on source characteristics

3. Key Features:
   - Shared HDR conversion task (PRD G8: HDR→SDR executed once, shared across qualities)
   - Post-processing tasks: fonts, chapters, sprites, validation, playlist generation
   - Task dependency tracking with DAG support
   - Weight calculation using `TaskWeighting` utilities
   - Hardware requirements tracking (GPU, memory estimates)
   - Uses proper `EncodingTaskType` constants from database models
   - Language-based audio task splitting option

4. Updated Project Configuration (`NoMercy.EncoderV2.csproj`):
   - Enabled `Tasks/ITaskSplitter.cs` and `Tasks/TaskSplitter.cs`
   - Enabled `Core/TaskWeighting.cs`
   - Excluded other Tasks/*.cs files with broken dependencies

5. Updated DI Configuration:
   - Added `using NoMercy.EncoderV2.Tasks;` to ServiceCollectionExtensions.cs
   - Registered `ITaskSplitter` as scoped service

**Task Distribution Strategies:**
| Strategy | Best For | Example |
|----------|----------|---------|
| SingleTask | Simple 1-quality jobs | Single 1080p output |
| ByResolution | Multi-quality encoding | 4K + 1080p + 720p outputs |
| ByStreamType | Parallel video/audio | When tasks can run independently |
| BySegment | Very long HLS content | >2 hour movies |
| Optimal | Any job | Auto-selects based on analysis |

**Build Status:**
- NoMercy.EncoderV2: BUILD SUCCEEDED

**Phase 5 Progress (Task Distribution):**
- ✅ TaskSplitter (Job → Task decomposition)
- ✅ NodeSelector (capability matching)
- ❌ JobDispatcher (queue integration)
- ❌ NodeHealthMonitor (30-second health checks)

**Next Steps:**
- ~~Implement NodeSelector for capability-based node matching~~ ✓

---

### 2026-02-03: NodeSelector Implementation (Phase 5)

**Task Completed:** Implement NodeSelector for capability-based node matching

**Changes Made:**

1. Created `INodeSelector.cs` in `src/NoMercy.EncoderV2/Tasks/`
   - Interface for node selection and capability matching
   - Enums for selection strategies: LeastLoaded, BestCapability, RoundRobin, Fastest, Auto
   - DTOs for selection options, results, and batch assignments:
     - `NodeSelectionOptions`: Strategy, GPU requirements, memory, heartbeat age
     - `NodeSelectionResult`: Selected node with score, alternatives, reason
     - `NodeCandidate`: Node with score breakdown and warnings
     - `BatchAssignmentResult`: For assigning multiple tasks
     - `TaskAssignment`, `UnassignedTask`: Individual assignment results

2. Implemented `NodeSelector.cs` with capability matching:
   - **LeastLoaded Strategy**: Select node with lowest current load percentage
   - **BestCapability Strategy**: Select node with highest hardware score
   - **RoundRobin Strategy**: Distribute tasks evenly across nodes
   - **Fastest Strategy**: Prefer GPU nodes, then highest CPU cores
   - **Auto Strategy**: Automatically choose based on task characteristics

3. Key Features:
   - `SelectNode()`: Select best node for a single task
   - `SelectNodesForTasks()`: Batch assignment with capacity tracking
   - `CanNodeHandleTask()`: Check if node meets task requirements
   - `CalculateNodeScore()`: Weighted scoring across multiple factors
   - `GetCapableNodes()`: List all nodes that can handle a task
   - `FilterHealthyNodes()`: Filter by heartbeat age
   - `DetermineOptimalStrategy()`: Auto-select strategy per task type

4. Scoring System (weighted factors):
   - GPU Match: 30% (NVIDIA bonus, GPU requirement match)
   - Capacity: 25% (available slots vs max concurrent tasks)
   - Memory: 15% (meets requirement + excess ratio)
   - CPU: 15% (normalized core count)
   - Acceleration: 15% (NVENC, QSV, VAAPI, VideoToolbox support)

5. Health Checks:
   - Node enabled/healthy status
   - Last heartbeat age validation (configurable, default 60s)
   - Capacity check (exclude full nodes option)
   - Memory requirement validation

6. Updated DI Configuration:
   - Added `INodeSelector` registration to `DependencyInjection/ServiceCollectionExtensions.cs`
   - Added `INodeSelector` registration to `Composition/DependencyInjection.cs`
   - Both registered as scoped services

**Build Status:**
- NoMercy.EncoderV2: BUILD SUCCEEDED

**Phase 5 Progress (Task Distribution):**
- ✅ TaskSplitter (Job → Task decomposition)
- ✅ NodeSelector (capability matching)
- ✅ JobDispatcher (queue integration)
- ❌ NodeHealthMonitor (30-second health checks)

**Next Steps:**
- ~~Implement JobDispatcher for queue integration~~ ✓

---

### 2026-02-03: JobDispatcher Implementation (Phase 5)

**Task Completed:** Implement JobDispatcher for queue integration

**Changes Made:**

1. Created `IJobDispatcher.cs` in `src/NoMercy.EncoderV2/Tasks/`
   - Interface for encoding job dispatching and management
   - Enums: `JobPriority` (Low, Normal, High, Urgent)
   - DTOs for dispatch options, results, and status:
     - `JobDispatchOptions`: Priority, split/node strategies, post-processing flags
     - `JobDispatchResult`: Success, job, tasks, weights, unassigned tasks
     - `JobCancelResult`: Success, cancelled/completed counts
     - `TaskRetryResult`: Success, retried count, exceeded max retries
     - `JobStatus`: Progress aggregation across all tasks

2. Implemented `JobDispatcher.cs` with full queue integration:
   - **Job Dispatch**: Create job, analyze media, split into tasks, optionally assign nodes
   - **Job Cancellation**: Cancel all pending tasks, update job state
   - **Task Retry**: Retry failed tasks with retry counting, reset job state
   - **Status Queries**: Get job status with aggregated progress from tasks
   - **Task Lifecycle**: Start, complete, fail tasks with node tracking
   - **Node Failure Handling**: Reassign tasks from unhealthy nodes
   - **Dependency Tracking**: Check task dependencies before execution

3. Key Features:
   - `DispatchAsync()`: Create job from profile, split tasks, optional node assignment
   - `CancelJobAsync()`: Cancel job and all non-completed tasks
   - `RetryFailedTasksAsync()`: Retry failed tasks respecting max retries
   - `GetJobStatusAsync()`: Aggregate progress with ETA calculation
   - `GetNextPendingTaskAsync()`: Get next executable task respecting dependencies
   - `AssignTaskToNodeAsync()`: Manually assign task to specific node
   - `StartTaskAsync()`: Mark task as running, update job state
   - `CompleteTaskAsync()`: Mark task complete, check job completion
   - `FailTaskAsync()`: Mark task failed, update job state if no remaining tasks
   - `RecordProgressAsync()`: Store progress snapshot for task
   - `ReassignTasksFromNodeAsync()`: Handle node failures gracefully

4. Integration Points:
   - Uses `ITaskSplitter` for job-to-task decomposition
   - Uses `INodeSelector` for batch task-to-node assignment
   - Uses `IStreamAnalyzer` for media file analysis
   - Uses `IProfileRepository` for profile lookup from database
   - Uses `QueueContext` for all database operations

5. Updated Project Configuration:
   - Enabled `ProfileRepository.cs` in csproj for profile access
   - Added `IJobDispatcher`, `IStreamAnalyzer`, `IProfileRepository` to DI

**Build Status:**
- NoMercy.EncoderV2: BUILD SUCCEEDED
- Full Solution: BUILD SUCCEEDED

**Phase 5 Progress (Task Distribution):**
- ✅ TaskSplitter (Job → Task decomposition)
- ✅ NodeSelector (capability matching)
- ✅ JobDispatcher (queue integration)
- ✅ NodeHealthMonitor (30-second health checks)

**Next Steps:**
- ~~Implement NodeHealthMonitor for 30-second health checks~~ ✓

---

### 2026-02-03: NodeHealthMonitor Implementation (Phase 5 Complete)

**Task Completed:** Implement NodeHealthMonitor for 30-second health checks

**Changes Made:**

1. Created `INodeHealthMonitor.cs` in `src/NoMercy.EncoderV2/Tasks/`
   - Interface for node health monitoring with comprehensive API
   - DTOs: `HealthCheckResult`, `NodeHealthStatus`, `HealthMonitorOptions`, `HeartbeatResult`
   - Operations: start/stop monitoring, health checks, heartbeat recording
   - Node management: enable, disable, mark healthy/unhealthy
   - Status queries: all nodes, single node, summary statistics

2. Implemented `NodeHealthMonitor.cs` as BackgroundService:
   - Inherits from `BackgroundService` for ASP.NET Core hosted service integration
   - 30-second periodic health checks (configurable via `HealthMonitorOptions`)
   - Heartbeat-based health detection with 60-second timeout (configurable)
   - Automatic task reassignment from unhealthy nodes

3. Key Features:
   - `PerformHealthCheckAsync()`: Check all nodes, update IsHealthy, reassign tasks
   - `RecordHeartbeatAsync()`: Record heartbeat from node, mark as healthy
   - `MarkNodeUnhealthyAsync()`: Manually mark node unhealthy with task reassignment
   - `MarkNodeHealthyAsync()`: Manually mark node healthy
   - `EnableNodeAsync()`: Enable node for task assignment
   - `DisableNodeAsync()`: Disable node with task reassignment
   - `GetAllNodeStatusesAsync()`: Get detailed status of all nodes
   - `GetNodeStatusAsync()`: Get status of specific node
   - `GetNodeSummaryAsync()`: Quick statistics (total, healthy, enabled, running tasks)

4. Health Detection Logic:
   - Nodes with heartbeat older than timeout are marked unhealthy
   - Hysteresis via `_consecutiveFailedChecks` prevents flapping
   - Configurable `FailedChecksBeforeUnhealthy` (default: 2)
   - New nodes without heartbeat get grace period (2x timeout)

5. Updated DI Configuration:
   - `ServiceCollectionExtensions.cs`: Added `HealthMonitorOptions` from `EncoderV2Options`
   - `ServiceCollectionExtensions.cs`: Registered `NodeHealthMonitor` as singleton and hosted service
   - `Composition/DependencyInjection.cs`: Added same registrations
   - Added health monitoring options to `EncoderV2Options`

6. EncoderV2Options Extended:
   - `HealthCheckIntervalSeconds` (default: 30)
   - `HeartbeatTimeoutSeconds` (default: 60)
   - `AutoReassignTasksOnNodeFailure` (default: true)
   - `VerboseHealthLogging` (default: false)

**Build Status:**
- NoMercy.EncoderV2: BUILD SUCCEEDED
- Full Solution: BUILD SUCCEEDED

**Phase 5 Progress (Task Distribution) - COMPLETE:**
- ✅ TaskSplitter (Job → Task decomposition)
- ✅ NodeSelector (capability matching)
- ✅ JobDispatcher (queue integration)
- ✅ NodeHealthMonitor (30-second health checks)

**Next Steps (Phase 6: Node Implementation):**
- ~~Create EncoderNode project~~ ✓ (already existed)
- ~~Implement NodeRegistration (phone-home + mDNS)~~ ✓ (already existed)
- ~~Implement node-side ProgressEmitter~~ ✓
- ~~Implement NodeCapabilities (GPU/CPU detection)~~ ✓ (already existed)

---

### 2026-02-03: ProgressEmitter Implementation (Phase 6)

**Task Completed:** Implement node-side ProgressEmitter for FFmpeg progress reporting

**Changes Made:**

1. Created `ProgressEmitter.cs` in `src/NoMercy.EncoderNode/Services/`
   - Implements `IProgressEmitter` interface for dependency injection
   - Parses FFmpeg progress output (frame, fps, time, bitrate, speed)
   - Supports both standard stderr output and -progress pipe:1 format
   - Throttles progress reports (default 1 second interval)
   - Reports task started/completed events to primary server
   - Calculates estimated time remaining based on encoding speed
   - HTTP-based progress reporting with Bearer token authentication

2. Key Features:
   - `ParseAndEmitAsync()`: Parse FFmpeg output and emit progress
   - `EmitProgressAsync()`: Send progress data to server with throttling
   - `CreateProgressCallback()`: Create callback for FFmpeg process integration
   - `ParseProgressLine()`: Extract metrics from FFmpeg stderr lines
   - `ReportTaskStartedAsync()`: Notify server when task begins
   - `ReportTaskCompletedAsync()`: Notify server when task ends
   - Throttling prevents overwhelming server with updates
   - Supports both user tokens and Keycloak service tokens

3. Created supporting NmSystem utilities:
   - `FFmpegAccelerationDetector.cs`: Detect available hardware acceleration
   - `GpuDeviceDetector.cs`: Detect GPU devices and capabilities
   - `Memory.cs`: System memory information (total/available)
   - Made `Cpu.Names()` public for cross-project access
   - Added `ServerHardwareCapabilities` DTO to EncoderNodeDtos.cs

4. Updated `EncoderNodeOptions.cs`:
   - Added `ProgressReportIntervalMs` (default: 1000ms)
   - Added `LogProgress` flag for console logging

5. Updated `Program.cs` DI configuration:
   - Registered `IProgressEmitter` as singleton
   - Registered `IKeycloakAuthService`, `IServerDiscoveryService`
   - Registered `NodeRegistrationService` as hosted service
   - Added `HttpClient` factory

**Build Status:**
- NoMercy.EncoderNode: BUILD SUCCEEDED
- NoMercy.NmSystem: BUILD SUCCEEDED

**Phase 6 Progress (Node Implementation) - COMPLETE:**
- ✅ EncoderNode project (pre-existing)
- ✅ NodeRegistration (pre-existing)
- ✅ ProgressEmitter
- ✅ NodeCapabilities (pre-existing via CapabilityDetector)

**Next Steps (Phase 7: API & Integration):**
- ~~Create ProfileController (CRUD endpoints)~~ ✓
- Create EncodingController (job submission)
- Create ProgressHub (SignalR real-time updates)
- Integrate with existing Queue system
- Add API documentation (Swagger)

---

### 2026-02-03: ProfilesController Implementation (Phase 7)

**Task Completed:** Create ProfilesController for EncoderV2 CRUD endpoints

**Changes Made:**

1. Created `ProfilesController.cs` in `src/NoMercy.Api/Controllers/V2/Dashboard/`
   - REST API v2 controller for encoding profile management
   - Inherits from `BaseController` for standardized error responses
   - Uses `[ApiVersion(2.0)]` for API versioning
   - Uses `IProfileRepository` from EncoderV2 for database operations
   - Requires moderator authorization for all endpoints

2. Endpoints Implemented:
   - `GET /api/v2/dashboard/encoder/profiles` - List all profiles
   - `GET /api/v2/dashboard/encoder/profiles/{id}` - Get profile by ULID
   - `POST /api/v2/dashboard/encoder/profiles` - Create new profile
   - `PATCH /api/v2/dashboard/encoder/profiles/{id}` - Update existing profile
   - `DELETE /api/v2/dashboard/encoder/profiles/{id}` - Delete profile
   - `GET /api/v2/dashboard/encoder/profiles/default` - Get default profile
   - `POST /api/v2/dashboard/encoder/profiles/{id}/duplicate` - Duplicate profile

3. Request DTOs Created:
   - `CreateProfileRequest`: Name (required), Container, Param, VideoProfiles, AudioProfiles, SubtitleProfiles
   - `UpdateProfileRequest`: All fields optional for partial updates
   - `DuplicateProfileRequest`: Optional new name for duplicated profile

4. Updated `NoMercy.Api.csproj`:
   - Added project reference to `NoMercy.EncoderV2`

**API Response Format:**
All endpoints return `StatusResponseDto<T>` with:
- `status`: "ok" or "error"
- `data`: Response payload
- `message`: Human-readable message
- `args`: Message interpolation arguments

**Build Status:**
- NoMercy.Api: BUILD SUCCEEDED

**Phase 7 Progress (API & Integration):**
- ✅ ProfileController (CRUD endpoints)
- ❌ EncodingController (job submission)
- ❌ ProgressHub (SignalR real-time updates)
- ❌ Integrate with existing Queue system
- ❌ Add API documentation (Swagger)

**Next Steps:**
- Implement EncodingController for job submission endpoints
